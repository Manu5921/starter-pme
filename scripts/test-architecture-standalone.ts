#!/usr/bin/env tsx

import { execSync } from 'child_process';
import { existsSync, readFileSync } from 'fs';

// Test d'architecture compl√®te sans d√©pendances de DB
class ArchitectureTestSuite {
  
  async testConfigGeneration() {
    console.log("üîß Test: G√©n√©ration de configuration...");
    
    try {
      // Test du g√©n√©rateur standalone
      execSync('npm run test:generation', { stdio: 'pipe' });
      console.log("   ‚úÖ G√©n√©ration de configuration: OK");
      return true;
    } catch (error) {
      console.log("   ‚ùå G√©n√©ration de configuration: √âCHEC");
      return false;
    }
  }

  testFileStructure() {
    console.log("üìÅ Test: Structure des fichiers...");
    
    const criticalFiles = [
      // Core
      'package.json',
      'next.config.ts',
      'tailwind.config.ts',
      
      // App structure
      'app/layout.tsx',
      'app/globals.css',
      
      // Components
      'components/shared/HeroSection.tsx',
      'components/shared/ServicesGrid.tsx',
      'components/shared/ContactForm.tsx',
      'components/templates/plumber/PlumberTemplate.tsx',
      
      // Database
      'db/schema.ts',
      'db/drizzle.ts',
      
      // Generators
      'lib/generators/client-generator.ts',
      'lib/deployment/vercel-deployer.ts',
      
      // Types
      'lib/types/database.ts',
      
      // Configuration examples
      'lib/configs/examples/dubois-plomberie.ts',
      
      // Demo page
      'app/demo/page.tsx',
      
      // Documentation
      'DEVBOOK.md',
      'QUICKSTART.md',
      'GENERATION_SYSTEM.md'
    ];

    let allPresent = true;
    const missingFiles = [];

    criticalFiles.forEach(file => {
      if (existsSync(file)) {
        console.log(`   ‚úÖ ${file}`);
      } else {
        console.log(`   ‚ùå ${file}`);
        missingFiles.push(file);
        allPresent = false;
      }
    });

    if (allPresent) {
      console.log("   ‚úÖ Structure des fichiers: OK");
    } else {
      console.log(`   ‚ùå ${missingFiles.length} fichier(s) manquant(s)`);
    }

    return allPresent;
  }

  testTemplateComponents() {
    console.log("üé® Test: Composants de template...");
    
    const templateFiles = [
      'components/templates/plumber/PlumberTemplate.tsx',
      'components/shared/HeroSection.tsx',
      'components/shared/ServicesGrid.tsx',
      'components/shared/ContactForm.tsx',
      'components/shared/Testimonials.tsx',
      'components/shared/FAQ.tsx'
    ];

    let componentsValid = true;

    templateFiles.forEach(file => {
      if (existsSync(file)) {
        try {
          const content = readFileSync(file, 'utf-8');
          
          // V√©rifications basiques
          const hasExport = content.includes('export');
          const hasImport = content.includes('import');
          const hasTypeScript = file.endsWith('.tsx');
          
          if (hasExport && hasImport && hasTypeScript) {
            console.log(`   ‚úÖ ${file}: Valide`);
          } else {
            console.log(`   ‚ö†Ô∏è  ${file}: Structure douteuse`);
            componentsValid = false;
          }
        } catch (error) {
          console.log(`   ‚ùå ${file}: Erreur de lecture`);
          componentsValid = false;
        }
      } else {
        console.log(`   ‚ùå ${file}: Manquant`);
        componentsValid = false;
      }
    });

    if (componentsValid) {
      console.log("   ‚úÖ Composants de template: OK");
    } else {
      console.log("   ‚ùå Probl√®mes d√©tect√©s dans les composants");
    }

    return componentsValid;
  }

  testSEOGeneration() {
    console.log("üéØ Test: G√©n√©ration SEO...");
    
    try {
      // Test manuel de SEO avec notre g√©n√©rateur standalone
      const businessName = "Test Business";
      const templateType = "plumber";
      const city = "Lyon";
      
      // Simulation de la g√©n√©ration SEO
      const title = `Plombier ${city} - D√©pannage 24h/24 | ${businessName}`;
      const description = `Plombier professionnel √† ${city}. Intervention rapide 24h/24 pour tous vos d√©pannages plomberie. Devis gratuit. ‚≠ê ${businessName}`;
      const keywords = [
        `plombier ${city.toLowerCase()}`,
        `d√©pannage plomberie ${city.toLowerCase()}`,
        `urgence plombier ${city.toLowerCase()}`,
        `fuite eau ${city.toLowerCase()}`,
        'plomberie 24h/24',
        'd√©bouchage canalisation',
        'installation sanitaire'
      ];

      // Validations SEO
      const titleValid = title.length > 10 && title.length < 60;
      const descriptionValid = description.length > 50 && description.length < 160;
      const keywordsValid = keywords.length >= 5;
      const localSEO = title.includes(city) && description.includes(city);

      console.log(`   ‚úÖ Title: ${titleValid ? 'OK' : '√âCHEC'} (${title.length} chars)`);
      console.log(`   ‚úÖ Description: ${descriptionValid ? 'OK' : '√âCHEC'} (${description.length} chars)`);
      console.log(`   ‚úÖ Keywords: ${keywordsValid ? 'OK' : '√âCHEC'} (${keywords.length} mots-cl√©s)`);
      console.log(`   ‚úÖ SEO Local: ${localSEO ? 'OK' : '√âCHEC'}`);

      const seoValid = titleValid && descriptionValid && keywordsValid && localSEO;
      
      if (seoValid) {
        console.log("   ‚úÖ G√©n√©ration SEO: OK");
      } else {
        console.log("   ‚ùå G√©n√©ration SEO: √âCHEC");
      }

      return seoValid;
    } catch (error) {
      console.log("   ‚ùå Erreur lors du test SEO");
      return false;
    }
  }

  testResponsiveDesign() {
    console.log("üì± Test: Design responsive...");
    
    const componentsToCheck = [
      'components/shared/HeroSection.tsx',
      'components/shared/ServicesGrid.tsx',
      'components/shared/ContactForm.tsx'
    ];

    let responsiveValid = true;

    componentsToCheck.forEach(file => {
      if (existsSync(file)) {
        try {
          const content = readFileSync(file, 'utf-8');
          
          // Rechercher les classes Tailwind responsive
          const hasMobileFirst = content.includes('sm:') || content.includes('md:') || content.includes('lg:');
          const hasFlexGrid = content.includes('flex') || content.includes('grid');
          const hasResponsiveSpacing = content.includes('p-') && content.includes('px-') || content.includes('py-');
          
          if (hasMobileFirst && hasFlexGrid) {
            console.log(`   ‚úÖ ${file}: Responsive`);
          } else {
            console.log(`   ‚ö†Ô∏è  ${file}: Possiblement non-responsive`);
            responsiveValid = false;
          }
        } catch (error) {
          console.log(`   ‚ùå ${file}: Erreur`);
          responsiveValid = false;
        }
      }
    });

    if (responsiveValid) {
      console.log("   ‚úÖ Design responsive: OK");
    } else {
      console.log("   ‚ùå Probl√®mes de responsive d√©tect√©s");
    }

    return responsiveValid;
  }

  testAccessibility() {
    console.log("‚ôø Test: Accessibilit√©...");
    
    const componentsToCheck = [
      'components/shared/HeroSection.tsx',
      'components/shared/ServicesGrid.tsx',
      'components/shared/ContactForm.tsx'
    ];

    let accessibilityValid = true;

    componentsToCheck.forEach(file => {
      if (existsSync(file)) {
        try {
          const content = readFileSync(file, 'utf-8');
          
          // V√©rifications d'accessibilit√© basiques
          const hasAltText = content.includes('alt=');
          const hasAriaLabels = content.includes('aria-') || content.includes('role=');
          const hasSemanticHTML = content.includes('<h1') || content.includes('<h2') || content.includes('<h3');
          const hasFocusStates = content.includes('focus:');
          
          let score = 0;
          if (hasAltText) score++;
          if (hasAriaLabels) score++;
          if (hasSemanticHTML) score++;
          if (hasFocusStates) score++;
          
          if (score >= 2) {
            console.log(`   ‚úÖ ${file}: Accessible (${score}/4)`);
          } else {
            console.log(`   ‚ö†Ô∏è  ${file}: Accessibilit√© limit√©e (${score}/4)`);
            accessibilityValid = false;
          }
        } catch (error) {
          console.log(`   ‚ùå ${file}: Erreur`);
          accessibilityValid = false;
        }
      }
    });

    if (accessibilityValid) {
      console.log("   ‚úÖ Accessibilit√©: OK");
    } else {
      console.log("   ‚ùå Am√©liorations d'accessibilit√© n√©cessaires");
    }

    return accessibilityValid;
  }

  testPerformance() {
    console.log("‚ö° Test: Optimisations de performance...");
    
    try {
      // V√©rifier la configuration Next.js
      if (existsSync('next.config.js')) {
        const nextConfig = readFileSync('next.config.js', 'utf-8');
        const hasStandalone = nextConfig.includes('standalone');
        const hasImageOptimization = nextConfig.includes('images');
        
        console.log(`   ‚úÖ Next.js config: ${hasStandalone ? 'Standalone OK' : 'Standard'}`);
        console.log(`   ‚úÖ Images: ${hasImageOptimization ? 'Optimis√©es' : 'Standard'}`);
      }
      
      // V√©rifier Tailwind
      if (existsSync('tailwind.config.js')) {
        console.log("   ‚úÖ Tailwind CSS: Configur√©");
      }
      
      // V√©rifier les composants pour les optimisations
      const componentsWithLazy = [];
      const templateFiles = [
        'components/templates/plumber/PlumberTemplate.tsx',
        'components/shared/HeroSection.tsx'
      ];
      
      templateFiles.forEach(file => {
        if (existsSync(file)) {
          const content = readFileSync(file, 'utf-8');
          if (content.includes('lazy') || content.includes('dynamic') || content.includes('motion')) {
            componentsWithLazy.push(file);
          }
        }
      });
      
      console.log(`   ‚úÖ Composants optimis√©s: ${componentsWithLazy.length}`);
      console.log("   ‚úÖ Performance: OK");
      return true;
      
    } catch (error) {
      console.log("   ‚ùå Erreur lors du test de performance");
      return false;
    }
  }

  testDocumentation() {
    console.log("üìö Test: Documentation...");
    
    const docFiles = [
      'DEVBOOK.md',
      'QUICKSTART.md', 
      'GENERATION_SYSTEM.md',
      'README.md'
    ];

    let docsValid = true;
    let docsPresent = 0;

    docFiles.forEach(file => {
      if (existsSync(file)) {
        try {
          const content = readFileSync(file, 'utf-8');
          if (content.length > 100) { // Doc basique
            console.log(`   ‚úÖ ${file}: Pr√©sent (${Math.round(content.length / 1024)}KB)`);
            docsPresent++;
          } else {
            console.log(`   ‚ö†Ô∏è  ${file}: Trop court`);
          }
        } catch (error) {
          console.log(`   ‚ùå ${file}: Erreur`);
          docsValid = false;
        }
      } else {
        console.log(`   ‚ûñ ${file}: Absent`);
      }
    });

    if (docsPresent >= 3) {
      console.log("   ‚úÖ Documentation: OK");
    } else {
      console.log("   ‚ö†Ô∏è  Documentation incompl√®te");
      docsValid = false;
    }

    return docsValid;
  }

  async runAllTests() {
    console.log("üèóÔ∏è  TEST D'ARCHITECTURE COMPL√àTE");
    console.log("=" .repeat(50));
    console.log();

    const testResults = {
      configGeneration: await this.testConfigGeneration(),
      fileStructure: this.testFileStructure(),
      templateComponents: this.testTemplateComponents(),
      seoGeneration: this.testSEOGeneration(),
      responsiveDesign: this.testResponsiveDesign(),
      accessibility: this.testAccessibility(),
      performance: this.testPerformance(),
      documentation: this.testDocumentation()
    };

    console.log("\nüìä R√âSULTATS D'ARCHITECTURE");
    console.log("=" .repeat(50));

    const passed = Object.values(testResults).filter(Boolean).length;
    const total = Object.keys(testResults).length;

    Object.entries(testResults).forEach(([test, result]) => {
      const status = result ? "‚úÖ" : "‚ùå";
      const testName = test.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
      console.log(`${status} ${testName}`);
    });

    console.log();
    console.log(`üìà Score: ${passed}/${total} tests r√©ussis (${Math.round((passed/total) * 100)}%)`);

    if (passed === total) {
      console.log("üéâ ARCHITECTURE VALID√âE - Pr√™te pour la production!");
    } else if (passed >= total * 0.8) {
      console.log("‚ö†Ô∏è  ARCHITECTURE ACCEPTABLE - Quelques am√©liorations recommand√©es");
    } else {
      console.log("üîß ARCHITECTURE √Ä AM√âLIORER - Corrections n√©cessaires");
    }

    return passed >= total * 0.8; // 80% minimum
  }
}

// Lancer les tests
async function main() {
  console.log("üß™ TESTS D'ARCHITECTURE STANDALONE");
  console.log("=" .repeat(60));
  console.log();

  const testSuite = new ArchitectureTestSuite();
  
  try {
    const success = await testSuite.runAllTests();
    process.exit(success ? 0 : 1);
  } catch (error) {
    console.error("üí• Erreur critique lors des tests:", error);
    process.exit(1);
  }
}

main();